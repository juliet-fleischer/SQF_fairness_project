# check for duplicates
duplicates <- sqf.complete.2023[duplicated(sqf.complete.2023), ] # no duplicates present
# fit a LASSO logistic regression for SUSPECT_ARRESTED_FLAG for variable selection
X.arrested <- model.matrix(SUSPECT_ARRESTED_FLAG ~ ., data = sqf.complete.2023)
str(sqf.complete.2023$SUSPECT_ARRESTED_FLAG)
# Identify columns with only one level
single_level_factors <- sapply(sqf.complete.2023, function(col) {
is.factor(col) && length(levels(col)) < 2
})
# Print the names of single-level factors
names(single_level_factors[single_level_factors])
# Identify columns with only one level
single_level_factors <- apply(sqf.complete.2023, 2, function(col) {
is.factor(col) && length(levels(col)) < 2
})
# Print the names of single-level factors
names(single_level_factors[single_level_factors])
single_level_factors
# fit a LASSO logistic regression for SUSPECT_ARRESTED_FLAG for variable selection
X.arrested <- model.matrix(SUSPECT_ARRESTED_FLAG ~ ., data = sqf.complete.2023)
# Identify columns with only one level
sapply(lapply(sqf.complete.2023, unqiue), length)
# Identify columns with only one level
sapply(lapply(sqf.complete.2023, unique), length)
# Identify columns with only one level
sapply(lapply(sqf.complete.2023, unique), length) == 1
# remove year column (as we only have 2023)
sqf.2023$YEAR2 <- NULL
# remove year column (as we only have 2023)
sqf.2023$YEAR2 <- NULL
# fit a LASSO logistic regression for SUSPECT_ARRESTED_FLAG for variable selection
X.arrested <- model.matrix(SUSPECT_ARRESTED_FLAG ~ ., data = sqf.complete.2023)
# complete case analysis based on already reduced data set
sqf.complete.2023 <- sqf.2023[complete.cases(sqf.2023), ]
# fit a LASSO logistic regression for SUSPECT_ARRESTED_FLAG for variable selection
X.arrested <- model.matrix(SUSPECT_ARRESTED_FLAG ~ ., data = sqf.complete.2023)
# Identify columns with only one level
sapply(lapply(sqf.complete.2023, unique), length) == 1
# Identify columns with only one level
which(sapply(lapply(sqf.complete.2023, unique), length) == 1)
# Identify columns with only one level
which(sapply(lapply(sqf.2023, unique), length) == 1)
sqf.2023$RECORD_STATUS_CODE <- NULL
# complete case analysis based on already reduced data set
sqf.complete.2023 <- sqf.2023[complete.cases(sqf.2023), ]
# fit a LASSO logistic regression for SUSPECT_ARRESTED_FLAG for variable selection
X.arrested <- model.matrix(SUSPECT_ARRESTED_FLAG ~ ., data = sqf.complete.2023)
?cv.glmnet
?glmnet
arrest.model <- glmnet(X.arrested, sqf.complete.2023$SUSPECT_ARRESTED_FLAG, family = "binomial", alpha = 1)
summary(arrest.model)
coefficients(arrest.model)
coefs(arrest.model)
coef(arrest.model, s = "lambda.min")
# Get the lambda sequence used in the model
lambdas <- arrest.model$lambda
# Inspect the coefficients at the minimum lambda value in the sequence
coef(arrest.model, s = min(lambdas))
names(sqf.complete.2023)
# reduce the complete data to a set of reasonable covariables
selected.attr <- c("STOP_ID", targets, protected.a, "STOP_LOCATION_PRECINCT",
"SUSPECT_WEIGHT", "WEAPON_FOUND_FLAG")
sqf.complete.2023 <- sqf.complete.2023[, selected.attr, with = FALSE]
targets
protected.a
# reduce the complete data to a set of reasonable covariables
selected.attr <- c("STOP_ID", targets, protected.a, "STOP_LOCATION_PRECINCT",
"SUSPECT_WEIGHT", "WEAPON_FOUND_FLAG")
sqf.complete.2023 <- sqf.complete.2023[, selected.attr]
str(sqf.complete.2023)
selected.attr
str(selected.attr)
sqf.complete.2023 <- sqf.complete.2023[, ..selected.attr]
source("~/Library/Mobile Documents/com~apple~CloudDocs/Documents/01_Studium/13_Jahr_03/21_TrustML/NYPD_SQF_data/Program/data_cleaning.R")
sqf.complete.2023
dim(sqf.complete.2023)
# fit a LASSO logistic regression for SUSPECT_ARRESTED_FLAG for variable selection
X.arrested <- model.matrix(SUSPECT_ARRESTED_FLAG ~ ., data = sqf.complete.2023)
arrest.model <- glmnet(X.arrested, sqf.complete.2023$SUSPECT_ARRESTED_FLAG, family = "binomial", alpha = 1)
# Get the lambda sequence used in the model
lambdas <- arrest.model$lambda
# Inspect the coefficients at the minimum lambda value in the sequence
coef(arrest.model, s = min(lambdas))
exp(-1.638672e-01)
exp(-3.179528e-01)
exp(-1.190364e-02)
nrow(sqf.complete.2023)
nrow(sqf.complete.2023) *0.1
idx.test <- sample(1:nrow(sqf.complete.2023), ceiling(0.1 * nrow(sqf.complete.2023)))
idx.test
test.set <- sqf.complete.2023[idx.test, ]
train.set <- sqf.complete.2023[-idx.test, ]
train.set
insta..packages("caret")
install.packages("caret")
library(caret)
?trainControl
str(sqf.complete.2023)
# fit regular logistic regression
arrest.model <- glm(SUSPECT_ARRESTED_FLAG ~ ., data = sqf.complete.2023, family = "binomial")
summary(arrest.model)
arrest.model.r <- glmnet(X.arrested, sqf.complete.2023$SUSPECT_ARRESTED_FLAG, family = "binomial", alpha = 1)
# Get the lambda sequence used in the model
lambdas <- arrest.model.r$lambda
# Inspect the coefficients at the minimum lambda value in the sequence
coef(arrest.model.r, s = min(lambdas))
summary(arrest.model)
1.905e-02
exp(1.905e-02)
exp(-1.424e+00)
exp(6.208e-03)
exp(1.016e-02)
set.seed(103)
idx.test <- sample(1:nrow(sqf.complete.2023), ceiling(0.1 * nrow(sqf.complete.2023)))
test.set <- sqf.complete.2023[idx.test, ]
train.set <- sqf.complete.2023[-idx.test, ]
dim(train.set)
dim(test.set)
# fit regular logistic regression
arrest.model <- glm(SUSPECT_ARRESTED_FLAG ~ ., data = train.set, family = "binomial")
summary(arrest.model)
library(pROC)
predicted <- predict(arrest.model, test.set, type = "response")
roc.curve <- roc(test$SUSPECT_ARRESTED_FLAG, predicted)
roc.curve <- roc(test.set$SUSPECT_ARRESTED_FLAG, predicted)
plot(roc.curve, col = "blue")
# fit regular logistic regression
arrest.model <- glm(SUSPECT_ARRESTED_FLAG ~ ., data = train.set, family = "binomial")
summary(arrest.model)
predicted <- predict(arrest.model, test.set, type = "response")
roc.curve <- roc(test.set$SUSPECT_ARRESTED_FLAG, predicted)
plot(roc.curve, col = "blue")
ggroc(roc.curve, col = "blue")
auc <- round(auc(test.set$SUSPECT_ARRESTED_FLAG, predicted), 2)
test.set$SUSPECT_ARRESTED_FLAG
source("~/Library/Mobile Documents/com~apple~CloudDocs/Documents/01_Studium/13_Jahr_03/21_TrustML/NYPD_SQF_data/Program/data_cleaning.R")
set.seed(103)
idx.test <- sample(1:nrow(sqf.complete.2023), ceiling(0.1 * nrow(sqf.complete.2023)))
test.set <- sqf.complete.2023[idx.test, ]
train.set <- sqf.complete.2023[-idx.test, ]
str(train.set$SUSPECT_ARRESTED_FLAG)
# fit regular logistic regression
arrest.model <- glm(SUSPECT_ARRESTED_FLAG ~ ., data = train.set, family = "binomial")
summary(arrest.model)
predicted <- predict(arrest.model, test.set, type = "response")
roc.curve <- roc(test.set$SUSPECT_ARRESTED_FLAG, predicted)
auc <- round(auc(test.set$SUSPECT_ARRESTED_FLAG, predicted), 2)
ggroc(roc.curve, col = "blue")
auc
?roc
rocobj <- roc(test.set$SUSPECT_ARRESTED_FLAG, predicted)
auc <- round(auc(test.set$SUSPECT_ARRESTED_FLAG, predicted), 2)
ggroc(rocobj, colour = 'steelblue', size = 2) +
ggtitle(paste0('ROC Curve ', '(AUC = ', auc, ')'))
ggroc(rocobj, colour = 'steelblue', size = 1) +
ggtitle(paste0('ROC Curve ', '(AUC = ', auc, ')'))
ggroc(rocobj, colour = 'steelblue', size = 1) +
ggtitle(paste0('ROC Curve ', '(AUC = ', auc, ')')) +
theme_minimal()
coords(rocobj, "best", ret = c("threshold", "accuracy", "sensitivity", "specificity"))
?roc
ggroc(rocobj, colour = 'steelblue', size = 1) +
ggtitle(paste0('ROC Curve ', '(AUC = ', auc, ')')) +
theme_minimal()
library(mlr3)
# train model with mlr3
task <- as_task_classif(sqf.complete.2023, target = "SUSPECT_ARRESTED_FLAG", positive = "Y")
# train model with mlr3
tsk_classif <- as_task_classif(sqf.complete.2023, target = "SUSPECT_ARRESTED_FLAG", positive = "Y")
tsk_classif$positive
splits <- partition(tsk_classif, ratio = 0.9)
# train model with mlr3
tsk_classif <- as_task_classif(splits$train, target = "SUSPECT_ARRESTED_FLAG", positive = "Y")
splits$train
tsk_classif <- as_task_classif(sqf.complete.2023, target = "SUSPECT_ARRESTED_FLAG", positive = "Y")
lrn_rpart <- lrn("classif.rpart", predict_type = "prob")
splits <- partition(tsk_classif, ratio = 0.9)
lrn_rpart$train(tsk_classif, splits$train)
tsk_classif
prediction
lrn_rpart
splits
splits$train
str(sqf.complete.2023)
lrn()
sqf.2023$WEAPON_FOUND_FLAG <- factor(sqf.2023$WEAPON_FOUND_FLAG)
source("~/Library/Mobile Documents/com~apple~CloudDocs/Documents/01_Studium/13_Jahr_03/21_TrustML/NYPD_SQF_data/Program/data_cleaning.R")
# train model with mlr3
tsk_classif <- as_task_classif(sqf.complete.2023, target = "SUSPECT_ARRESTED_FLAG", positive = "Y")
lrn_rpart <- lrn("classif.rpart", predict_type = "prob")
splits <- partition(tsk_classif, ratio = 0.9)
lrn_rpart$train(tsk_classif, splits$train)
prediction <- lrn_rpart$predict(tsk_classif, splits$test)
prediction
prediction$score
prediction$score(measure)
prediction$confusion
measure <- msr("classif.auc")
prediction$score(measure)
autoplot(prediction)
table(sqf.complete.2023$SUSPECT_ARRESTED_FLAG)
table(sqf.complete.2023$SUMMONS_ISSUED_FLAG)
table(sqf.complete.2023$FRISKED_FLAG)
table(sqf.complete.2023$SEARCHED_FLAG)
autoplot(prediction)
# perform CV
rr <- resample(lrn_rpart, tsk_classif, resampling)
set.seed(103)
tsk_classif <- as_task_classif(sqf.complete.2023, target = "SUSPECT_ARRESTED_FLAG", positive = "Y")
lrn_rpart <- lrn("classif.rpart", predict_type = "prob")
measure <- msr("classif.auc")
splits <- partition(tsk_classif, ratio = 0.9)
# train
lrn_rpart$train(tsk_classif, splits$train)
# predict
prediction <- lrn_rpart$predict(tsk_classif, splits$test)
# evaluate
prediction$confusion
prediction$score(measure)
# with cv
# define CV
resampling <- rsmp("cv", folds = 5)
# perform CV
rr <- resample(lrn_rpart, tsk_classif, resampling)
set.seed(103)
tsk_classif <- as_task_classif(sqf.complete.2023, target = "SUSPECT_ARRESTED_FLAG", positive = "Y")
lrn_rpart <- lrn("classif.rpart", predict_type = "prob")
measure <- msr("classif.auc")
splits <- partition(tsk_classif, ratio = 0.9)
# train
lrn_rpart$train(tsk_classif, splits$train)
# predict
prediction <- lrn_rpart$predict(tsk_classif, splits$test)
# evaluate
prediction$confusion
prediction$score(measure)
autoplot(prediction, type = "roc")
library(mlr3viz)
autoplot(prediction, type = "roc")
rsmp("cv", folds = 5)
# with cv
# define CV
cv5 <- rsmp("cv", folds = 5)
cv5 <- rsmp("cv", folds = 5)
# perform CV
rr <- resample(tsk_classif, lrn_rpart, cv5)
rr
acc <- rr$score(measure)
acc[, .(iteration, classif.auc)]
rr$aggreate(measure)
rr$aggregate(measure)
# get the predictions of each fold
rrp <- rr$prediction()
str(rrp)
rrp[1:2]
# get the predictions of each fold
rrp <- rr$prediction()
rrp[1:2]
# get the predictions of each fold
rrp <- rr$predictions()
rrp[1:2]
rrp[1]
rrp[1]$confusion
rrp[1]
xtabs(~ truth + response, rrp$data())
xtabs(~ truth + response, rrp[1])
xtabs(truth ~ response, rrp[1])
str(rrp[1])
as.data.frame(rrp[1])
rrp[1]
rrp1 <- rrp[1]
rrp1
set.seed(103)
tsk_classif <- as_task_classif(sqf.complete.2023, target = "SUSPECT_ARRESTED_FLAG", positive = "Y")
lrn_rpart <- lrn("classif.rpart", predict_type = "prob")
measure <- msr("classif.auc")
splits <- partition(tsk_classif, ratio = 0.9)
# train
lrn_rpart$train(tsk_classif, splits$train)
# predict
prediction <- lrn_rpart$predict(tsk_classif, splits$test)
# evaluate
prediction$confusion
prediction$score(measure)
prediction
# fit regular logistic regression
# leave 10 % out for testing the fairness definitions
set.seed(103)
idx.test <- sample(1:nrow(sqf.complete.2023), ceiling(0.1 * nrow(sqf.complete.2023)))
test.set <- sqf.complete.2023[idx.test, ]
train.set <- sqf.complete.2023[-idx.test, ]
arrest.model <- glm(SUSPECT_ARRESTED_FLAG ~ ., data = train.set, family = "binomial")
summary(arrest.model)
predicted <- predict(arrest.model, test.set, type = "response")
rocobj <- roc(test.set$SUSPECT_ARRESTED_FLAG, predicted)
auc <- round(auc(test.set$SUSPECT_ARRESTED_FLAG, predicted), 2)
ggroc(rocobj, colour = 'steelblue', size = 1) +
ggtitle(paste0('ROC Curve ', '(AUC = ', auc, ')')) +
theme_minimal()
coords(rocobj, "best", ret = c("threshold", "accuracy", "sensitivity", "specificity"))
prediction
predicted
prediction
test.set
prediction
# leave 10 % out for testing the fairness definitions
set.seed(103)
idx.test <- sample(1:nrow(sqf.complete.2023), ceiling(0.1 * nrow(sqf.complete.2023)))
test.set <- sqf.complete.2023[idx.test, ]
train.set <- sqf.complete.2023[-idx.test, ]
arrest.model <- glm(SUSPECT_ARRESTED_FLAG ~ ., data = train.set, family = "binomial")
summary(arrest.model)
predicted <- predict(arrest.model, test.set, type = "response")
predicted.dt <- data.table(
row_ID = idx.test,
truth = test.set$SUSPECT_ARRESTED_FLAG,
response = predicted
)
predicted.dt
coords(rocobj, "best", ret = c("threshold", "accuracy", "sensitivity", "specificity"))
coords(rocobj, "best")$threshold
as.factor(predicted > coords(rocobj, "best")$threshold)
predicted.dt
rocobj
roc(test.set$SUSPECT_ARRESTED_FLAG, predicted)
# hard label classifier based on optimal threshold or 0.5?
predicted.dt <- data.table(
row_ID = idx.test,
truth = test.set$SUSPECT_ARRESTED_FLAG,
response_opt = as.factor(ifelse(predicted > coords(rocobj, "best")$threshold, "Y", "N")),
prob = predicted
)
predicted.dt
# hard label classifier based on optimal threshold or 0.5?
predicted.dt <- data.table(
row_ID = idx.test,
truth = test.set$SUSPECT_ARRESTED_FLAG,
response_opt = as.factor(ifelse(predicted > coords(rocobj, "best")$threshold, "Y", "N")),
response_05 = as.factor(ifelse(predicted > 0.5, "Y", "N")),
prob = predicted
)
predicted.dt
# hard label classifier based on optimal threshold or 0.5?
predicted.dt <- data.table(
row_ID = idx.test,
truth = test.set$SUSPECT_ARRESTED_FLAG,
response_opt = as.factor(ifelse(predicted < coords(rocobj, "best")$threshold, "Y", "N")),
response_05 = as.factor(ifelse(predicted > 0.5, "Y", "N")),
prob = predicted
)
predicted.dt
# hard label classifier based on optimal threshold or 0.5?
predicted.dt <- data.table(
row_ID = idx.test,
truth = test.set$SUSPECT_ARRESTED_FLAG,
response_opt = as.factor(ifelse(predicted > coords(rocobj, "best")$threshold, "Y", "N")),
response_05 = as.factor(ifelse(predicted > 0.5, "Y", "N")),
prob = predicted
)
predicted.dt
source("~/Library/Mobile Documents/com~apple~CloudDocs/Documents/01_Studium/13_Jahr_03/21_TrustML/NYPD_SQF_data/setup.R")
source("~/Library/Mobile Documents/com~apple~CloudDocs/Documents/01_Studium/13_Jahr_03/21_TrustML/NYPD_SQF_data/program/modelling.R")
ggroc(rocobj, colour = 'steelblue', size = 1) +
ggtitle(paste0('ROC Curve ', '(AUC = ', auc, ')')) +
theme_minimal()
### --- logistic regression --- ###
# leave 10 % out for testing the fairness definitions
set.seed(103)
idx.test <- sample(1:nrow(sqf.complete.2023), ceiling(0.1 * nrow(sqf.complete.2023)))
test.set <- sqf.complete.2023[idx.test, ]
train.set <- sqf.complete.2023[-idx.test, ]
# create row_idx column to double check
# test.set$row_idx <- idx.test
other.targets <- setdiff(targets, "SUSPECT_ARRESTED_FLAG")
arrest.model <- glm(SUSPECT_ARRESTED_FLAG ~ .,
data = train.set[, !..other.targets, with = FALSE],
family = "binomial")
summary(arrest.model)
predicted <- predict(arrest.model, test.set, type = "response")
rocobj <- roc(test.set$SUSPECT_ARRESTED_FLAG, predicted)
auc <- round(auc(test.set$SUSPECT_ARRESTED_FLAG, predicted), 2)
ggroc(rocobj, colour = 'steelblue', size = 1) +
ggtitle(paste0('ROC Curve ', '(AUC = ', auc, ')')) +
theme_minimal()
coords(rocobj, "best", ret = c("threshold", "accuracy", "sensitivity", "specificity"))
# hard label classifier based on optimal threshold or 0.5?
predicted.dt <- data.table(
STOP_ID = test.set$STOP_ID,
# row_ID = test.set$row_idx,
truth = test.set$SUSPECT_ARRESTED_FLAG,
response_opt = as.factor(ifelse(predicted > coords(rocobj, "best")$threshold, "Y", "N")),
response_05 = as.factor(ifelse(predicted > 0.5, "Y", "N")),
prob = predicted,
age = test.set$SUSPECT_REPORTED_AGE,
location = test.set$STOP_LOCATION_BOR,
sex = test.set$SUSPECT_SEX,
race = test.set$SUSPECT_RACE_DESCRIPTION
)
head(predicted.dt)
str(train.set)
# hard label classifier based on optimal threshold or 0.5?
predicted.dt <- data.table(
STOP_ID = test.set$STOP_ID,
# row_ID = test.set$row_idx,
truth = test.set$SUSPECT_ARRESTED_FLAG,
response_opt = as.factor(ifelse(predicted > coords(rocobj, "best")$threshold, 1, 0)),
response_05 = as.factor(ifelse(predicted > 0.5, 1, 0)),
prob = predicted,
age = test.set$SUSPECT_REPORTED_AGE,
location = test.set$STOP_LOCATION_BOR,
sex = test.set$SUSPECT_SEX,
race = test.set$SUSPECT_RACE_DESCRIPTION
)
head(predicted.dt)
predicted.dt |>
group_by(sex) |>
summarise(prop = sum(response) / n())
predicted.dt |>
group_by(sex) |>
summarise(prop = sum(response_opt) / n())
# hard label classifier based on optimal threshold or 0.5?
predicted.dt <- data.table(
STOP_ID = test.set$STOP_ID,
# row_ID = test.set$row_idx,
truth = test.set$SUSPECT_ARRESTED_FLAG,
response_opt = ifelse(predicted > coords(rocobj, "best")$threshold, 1, 0),
#  response_05 = as.factor(ifelse(predicted > 0.5, 1, 0)),
prob = predicted,
age = test.set$SUSPECT_REPORTED_AGE,
location = test.set$STOP_LOCATION_BOR,
sex = test.set$SUSPECT_SEX,
race = test.set$SUSPECT_RACE_DESCRIPTION
)
predicted.dt |>
group_by(sex) |>
summarise(prop = sum(response_opt) / n())
predicted.dt |>
group_by(sex) |>
summarise(count = n())
predicted.dt[response_opt == 1 & sex == 1, ]
nrow(predicted.dt[response_opt == 1 & sex == 1, ])
nrow(predicted.dt[sex == 1])
nrow(predicted.dt[response_opt == 1 & sex == 1, ]) / nrow(predicted.dt[sex == 1])
nrow(predicted.dt[response_opt == 1 & sex == 0, ]) / nrow(predicted.dt[sex == 0])
predicted.dt[, .(prop = mean(response_opt)), by = sex]
aggregate(predicted ~ test.set$SUSPECT_SEX, FUN = mean)
# Statistical Parity for SUSPECT_ARRESTED_FLAG
# P(d = 1 | Y = 1) = P(d = 1 | Y = 0)
predicted.dt[, .(prop = mean(response_opt)), by = sex]
# It is more likely for females to be arrested
predicted.dt[, .(prop = mean(response_opt)), by = race]
# It is more likely for females to be arrested
predicted.dt[, .(prop = mean(response_opt)), by = race][, order(prop)]
# It is more likely for females to be arrested
predicted.dt[, .(prop = mean(response_opt)), by = race][order(prop)]
rocobj <- roc(test.set$SUSPECT_ARRESTED_FLAG, predicted)
test <- train.set[, !..other.targets, with = FALSE]
str(test$SUSPECT_ARRESTED_FLAG)
table(test$SUSPECT_ARRESTED_FLAG)
predicted.dt[, .N, by = race]
protected.a
summary(arrest.model)
exp(1.999e+00)
exp(9.413e-01)
exp(2.568e+00)
test.set
test.set[, `:=`(
prob = predicted,
response = ifelse(predicted > coords(rocobj, "best")$threshold, 1, 0)
)]
test.set
test.set <- test.set |>
select(STOP_ID, SUSPECT_ARRESTED_FLAG, prob, response, everything())
test.set
predicted.dt[, .(prop = mean(response_opt)), by = SUSPECT_SEX]
test.set[, .(prop = mean(response_opt)), by = SUSPECT_SEX]
test.set[, .(prop = mean(response)), by = SUSPECT_SEX]
# It is more likely for females to be arrested
test.set[, .(prop = mean(response)), by = SUSPECT_RACE_DESCRIPTION][order(prop)]
test.set[, .N, by = SUSPECT_RACE_DESCRIPTION]
test.set[, .(prop = mean(response)), by = .(SUSPECT_SEX, WEAPON_FOUND_FLAG)]
names(test.set)
# Conditional statistical parity
test.set[, .(prop = mean(response)), by = .(SUSPECT_SEX, STOP_LOCATION_BORO_NAME)]
# Conditional statistical parity
test.set[, .(prop = mean(response)), by = .(SUSPECT_SEX, STOP_LOCATION_BORO_NAME)][order(SUSPECT_SEX)]
test.set[, .(prop = mean(response)), by = .(SUSPECT_RACE_DESCRIPTION, WEAPON_FOUND_FLAG)][order(prop)]
test.set[, .(prop = mean(response)), by = .(SUSPECT_RACE_DESCRIPTION, WEAPON_FOUND_FLAG)][order(SUSPECT_RACE_DESCRIPTION)]
test.set[, .(prop = mean(response)), by = .(SUSPECT_RACE_DESCRIPTION, STOP_LOCATION_BORO_NAME)][order(SUSPECT_RACE_DESCRIPTION)]
test.set
# Predictive parity
test.set[, .(prop = mean(SUSPECT_ARRESTED_FLAG)), by = .(SUSPECT_SEX, response)]
n <- nrow(sqf.2023)
n
sqf.2023 <- read_excel("Data/sqf-2023.xlsx")
str(sqf.2023)
setDT(sqf.2023)
n <- nrow(sqf.2023)
n
nrow(sqf.complete.2023)
targets
protected.a
unique(sqf.2023$STOP_LOCATION_BORO_NAME)
unique(sqf.2023$SUSPECT_RACE_DESCRIPTION)
length(unique(sqf.2023$SUSPECT_RACE_DESCRIPTION))
length(unique(sqf.2023$STOP_LOCATION_PRECINCT))
source("~/Library/Mobile Documents/com~apple~CloudDocs/Documents/01_Studium/13_Jahr_03/21_TrustML/NYPD_SQF_data/program/description.R")
prop.data$STOP_LOCATION_BORO_NAME
prop.data$SUSPECT_SEX
prop.data$SUSPECT_RACE_DESCRIPTION
sqf.2023$SUSPECT_SEX <- factor(sqf.2023$SUSPECT_SEX, levels = c("MALE", "FEMALE"), labels = c(1, 0))
source("~/Library/Mobile Documents/com~apple~CloudDocs/Documents/01_Studium/13_Jahr_03/21_TrustML/NYPD_SQF_data/program/data_cleaning.R")
