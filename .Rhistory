prop.data <- list(lenght(targets))
prop.data <- list(length(targets))
prop.data
prop.data <- list()
prop.data <- list()
for (t in targets) {
# Conditional PAs
p <- sqf.complete.2023 |>
mutate(SUSPECT_RACE_DESCRIPTION = factor(SUSPECT_RACE_DESCRIPTION,
levels = rev(levels(SUSPECT_RACE_DESCRIPTION)))) |>
ggplot(aes(x = .data[[t]], fill = SUSPECT_RACE_DESCRIPTION)) +
geom_bar(position = "fill")
print(p)
prop.data[[t]] <- sqf.complete.2023 |>
group_by(.data[[t]], SUSPECT_RACE_DESCRIPTION) |>
summarise(count = n()) |>
mutate(prop = count / sum(count))
}
prop.data$SUSPECT_ARRESTED_FLAG
str(prop.c)
str(prop.data)
prop.data
# PAs
protected.a <- c("SUSPECT_REPORTED_AGE", "STOP_LOCATION_BORO_NAME",
"SUSPECT_SEX", "SUSPECT_RACE_DESCRIPTION")
prop.data <- list()
for (t in targets) {
p <- sqf.complete.2023 |>
mutate(SUSPECT_SEX = factor(SUSPECT_SEX,
levels = rev(levels(SUSPECT_SEX)))) |>
ggplot(aes(x = .data[[t]], fill = SUSPECT_SEX)) +
geom_bar(position = "fill")
print(p)
prop.data[[t]] <- sqf.complete.2023 |>
group_by(.data[[t]], SUSPECT_SEX) |>
summarise(count = n()) |>
mutate(prop = count / sum(count))
}
prop.data
for(a in protected.a) {
prop.data <- list()
for (t in targets) {
p <- sqf.complete.2023 |>
mutate(.data[[a]] = factor(.data[[a]],
protected.a
for(a in protected.a) {
prop.data <- list()
for (t in targets) {
p <- sqf.complete.2023 |>
mutate(a = factor(.data[[a]],
levels = rev(levels(.data[[a]])))) |>
ggplot(aes(x = .data[[t]], fill = .data[[a]])) +
geom_bar(position = "fill")
print(p)
prop.data[[t]] <- sqf.complete.2023 |>
group_by(.data[[t]], .data[[a]]) |>
summarise(count = n()) |>
mutate(prop = count / sum(count))
}
}
View(prop.data)
prop.data$SUSPECT_ARRESTED_FLAG
p
protected.a[-1]
prop.data.list <- list()
for(a in protected.a[-1]) {
prop.data[[a]] <- list()
for (t in targets) {
p <- sqf.complete.2023 |>
mutate(a = factor(.data[[a]],
levels = rev(levels(.data[[a]])))) |>
ggplot(aes(x = .data[[t]], fill = .data[[a]])) +
geom_bar(position = "fill")
print(p)
prop.data[[t]] <- sqf.complete.2023 |>
group_by(.data[[t]], .data[[a]]) |>
summarise(count = n()) |>
mutate(prop = count / sum(count))
}
}
prop.data$SUSPECT_SEX
prop.data.list <- list()
for(a in protected.a[-1]) {
prop.data[[a]] <- list()
for (t in targets) {
p <- sqf.complete.2023 |>
mutate(a = factor(.data[[a]],
levels = rev(levels(.data[[a]])))) |>
ggplot(aes(x = .data[[t]], fill = .data[[a]])) +
geom_bar(position = "fill")
print(p)
prop.data[[a]][[t]] <- sqf.complete.2023 |>
group_by(.data[[t]], .data[[a]]) |>
summarise(count = n()) |>
mutate(prop = count / sum(count))
}
}
prop.data <- list()
for(a in protected.a[-1]) {
prop.data[[a]] <- list()
for (t in targets) {
p <- sqf.complete.2023 |>
mutate(a = factor(.data[[a]],
levels = rev(levels(.data[[a]])))) |>
ggplot(aes(x = .data[[t]], fill = .data[[a]])) +
geom_bar(position = "fill")
print(p)
prop.data[[a]][[t]] <- sqf.complete.2023 |>
group_by(.data[[t]], .data[[a]]) |>
summarise(count = n()) |>
mutate(prop = count / sum(count))
}
}
prop.data$STOP_LOCATION_BORO_NAME
prop.data <- list()
for(a in protected.a[-1]) {
prop.data[[a]] <- list()
for (t in targets) {
p <- sqf.complete.2023 |>
mutate(a = factor(.data[[a]], levels = rev(levels(.data[[a]])))) |>
ggplot(aes(x = .data[[t]], fill = .data[[a]])) +
geom_bar(position = "fill") +
labs(x = t, fill = a, title = paste("Distribution of", t, "by", a)) +
theme_minimal()
print(p)
prop.data[[a]][[t]] <- sqf.complete.2023 |>
group_by(.data[[t]], .data[[a]]) |>
summarise(count = n()) |>
mutate(prop = count / sum(count))
}
}
# fit a LASSO logistic regression for SUSPECT_ARRESTED_FLAG for variable selection
X.arrested <- model.matrix(SUSPECT_ARRESTED_FLAG ~ ., data = sqf.complete.2023))
# fit a LASSO logistic regression for SUSPECT_ARRESTED_FLAG for variable selection
X.arrested <- model.matrix(SUSPECT_ARRESTED_FLAG ~ ., data = sqf.complete.2023)
X.arrested
str(sqf.complete.2023$SUSPECT_ARRESTED_FLAG)
# convert targets to factor
sqf.2023$SUSPECT_ARRESTED_FLAG <- factor(sqf.2023$SUSPECT_ARRESTED_FLAG, levels = c("Y", "N"), labels = c(1,0))
# Missing data handling
na.count <- apply(sqf.2023, 2, function(x) sum(is.na(x)))
# omit the columns that have more than 30% missing values
# (because no reasonable imputation possible, these are columns that are basically not important)
discard.cols <- names(sqf.2023)[(na.count / n) > 0.3]
sqf.2023[, (discard.cols):= NULL]
discard.cols.2 <- names(sqf.2023)[apply(sqf.2023, 2, function(x) sum(is.na(x))) > 0][1:4]
sqf.2023[, (discard.cols.2) := NULL]
# complete case analysis based on already reduced data set
sqf.complete.2023 <- sqf.2023[complete.cases(sqf.2023), ]
# check for outliers
summary(sqf.complete.2023)
# Height is measured in feet
# check for duplicates
duplicates <- sqf.complete.2023[duplicated(sqf.complete.2023), ] # no duplicates present
# fit a LASSO logistic regression for SUSPECT_ARRESTED_FLAG for variable selection
X.arrested <- model.matrix(SUSPECT_ARRESTED_FLAG ~ ., data = sqf.complete.2023)
str(sqf.complete.2023$SUSPECT_ARRESTED_FLAG)
# Identify columns with only one level
single_level_factors <- sapply(sqf.complete.2023, function(col) {
is.factor(col) && length(levels(col)) < 2
})
# Print the names of single-level factors
names(single_level_factors[single_level_factors])
# Identify columns with only one level
single_level_factors <- apply(sqf.complete.2023, 2, function(col) {
is.factor(col) && length(levels(col)) < 2
})
# Print the names of single-level factors
names(single_level_factors[single_level_factors])
single_level_factors
# fit a LASSO logistic regression for SUSPECT_ARRESTED_FLAG for variable selection
X.arrested <- model.matrix(SUSPECT_ARRESTED_FLAG ~ ., data = sqf.complete.2023)
# Identify columns with only one level
sapply(lapply(sqf.complete.2023, unqiue), length)
# Identify columns with only one level
sapply(lapply(sqf.complete.2023, unique), length)
# Identify columns with only one level
sapply(lapply(sqf.complete.2023, unique), length) == 1
# remove year column (as we only have 2023)
sqf.2023$YEAR2 <- NULL
# remove year column (as we only have 2023)
sqf.2023$YEAR2 <- NULL
# fit a LASSO logistic regression for SUSPECT_ARRESTED_FLAG for variable selection
X.arrested <- model.matrix(SUSPECT_ARRESTED_FLAG ~ ., data = sqf.complete.2023)
# complete case analysis based on already reduced data set
sqf.complete.2023 <- sqf.2023[complete.cases(sqf.2023), ]
# fit a LASSO logistic regression for SUSPECT_ARRESTED_FLAG for variable selection
X.arrested <- model.matrix(SUSPECT_ARRESTED_FLAG ~ ., data = sqf.complete.2023)
# Identify columns with only one level
sapply(lapply(sqf.complete.2023, unique), length) == 1
# Identify columns with only one level
which(sapply(lapply(sqf.complete.2023, unique), length) == 1)
# Identify columns with only one level
which(sapply(lapply(sqf.2023, unique), length) == 1)
sqf.2023$RECORD_STATUS_CODE <- NULL
# complete case analysis based on already reduced data set
sqf.complete.2023 <- sqf.2023[complete.cases(sqf.2023), ]
# fit a LASSO logistic regression for SUSPECT_ARRESTED_FLAG for variable selection
X.arrested <- model.matrix(SUSPECT_ARRESTED_FLAG ~ ., data = sqf.complete.2023)
?cv.glmnet
?glmnet
arrest.model <- glmnet(X.arrested, sqf.complete.2023$SUSPECT_ARRESTED_FLAG, family = "binomial", alpha = 1)
summary(arrest.model)
coefficients(arrest.model)
coefs(arrest.model)
coef(arrest.model, s = "lambda.min")
# Get the lambda sequence used in the model
lambdas <- arrest.model$lambda
# Inspect the coefficients at the minimum lambda value in the sequence
coef(arrest.model, s = min(lambdas))
names(sqf.complete.2023)
# reduce the complete data to a set of reasonable covariables
selected.attr <- c("STOP_ID", targets, protected.a, "STOP_LOCATION_PRECINCT",
"SUSPECT_WEIGHT", "WEAPON_FOUND_FLAG")
sqf.complete.2023 <- sqf.complete.2023[, selected.attr, with = FALSE]
targets
protected.a
# reduce the complete data to a set of reasonable covariables
selected.attr <- c("STOP_ID", targets, protected.a, "STOP_LOCATION_PRECINCT",
"SUSPECT_WEIGHT", "WEAPON_FOUND_FLAG")
sqf.complete.2023 <- sqf.complete.2023[, selected.attr]
str(sqf.complete.2023)
selected.attr
str(selected.attr)
sqf.complete.2023 <- sqf.complete.2023[, ..selected.attr]
source("~/Library/Mobile Documents/com~apple~CloudDocs/Documents/01_Studium/13_Jahr_03/21_TrustML/NYPD_SQF_data/Program/data_cleaning.R")
sqf.complete.2023
dim(sqf.complete.2023)
# fit a LASSO logistic regression for SUSPECT_ARRESTED_FLAG for variable selection
X.arrested <- model.matrix(SUSPECT_ARRESTED_FLAG ~ ., data = sqf.complete.2023)
arrest.model <- glmnet(X.arrested, sqf.complete.2023$SUSPECT_ARRESTED_FLAG, family = "binomial", alpha = 1)
# Get the lambda sequence used in the model
lambdas <- arrest.model$lambda
# Inspect the coefficients at the minimum lambda value in the sequence
coef(arrest.model, s = min(lambdas))
exp(-1.638672e-01)
exp(-3.179528e-01)
exp(-1.190364e-02)
nrow(sqf.complete.2023)
nrow(sqf.complete.2023) *0.1
idx.test <- sample(1:nrow(sqf.complete.2023), ceiling(0.1 * nrow(sqf.complete.2023)))
idx.test
test.set <- sqf.complete.2023[idx.test, ]
train.set <- sqf.complete.2023[-idx.test, ]
train.set
insta..packages("caret")
install.packages("caret")
library(caret)
?trainControl
str(sqf.complete.2023)
# fit regular logistic regression
arrest.model <- glm(SUSPECT_ARRESTED_FLAG ~ ., data = sqf.complete.2023, family = "binomial")
summary(arrest.model)
arrest.model.r <- glmnet(X.arrested, sqf.complete.2023$SUSPECT_ARRESTED_FLAG, family = "binomial", alpha = 1)
# Get the lambda sequence used in the model
lambdas <- arrest.model.r$lambda
# Inspect the coefficients at the minimum lambda value in the sequence
coef(arrest.model.r, s = min(lambdas))
summary(arrest.model)
1.905e-02
exp(1.905e-02)
exp(-1.424e+00)
exp(6.208e-03)
exp(1.016e-02)
set.seed(103)
idx.test <- sample(1:nrow(sqf.complete.2023), ceiling(0.1 * nrow(sqf.complete.2023)))
test.set <- sqf.complete.2023[idx.test, ]
train.set <- sqf.complete.2023[-idx.test, ]
dim(train.set)
dim(test.set)
# fit regular logistic regression
arrest.model <- glm(SUSPECT_ARRESTED_FLAG ~ ., data = train.set, family = "binomial")
summary(arrest.model)
library(pROC)
predicted <- predict(arrest.model, test.set, type = "response")
roc.curve <- roc(test$SUSPECT_ARRESTED_FLAG, predicted)
roc.curve <- roc(test.set$SUSPECT_ARRESTED_FLAG, predicted)
plot(roc.curve, col = "blue")
# fit regular logistic regression
arrest.model <- glm(SUSPECT_ARRESTED_FLAG ~ ., data = train.set, family = "binomial")
summary(arrest.model)
predicted <- predict(arrest.model, test.set, type = "response")
roc.curve <- roc(test.set$SUSPECT_ARRESTED_FLAG, predicted)
plot(roc.curve, col = "blue")
ggroc(roc.curve, col = "blue")
auc <- round(auc(test.set$SUSPECT_ARRESTED_FLAG, predicted), 2)
test.set$SUSPECT_ARRESTED_FLAG
source("~/Library/Mobile Documents/com~apple~CloudDocs/Documents/01_Studium/13_Jahr_03/21_TrustML/NYPD_SQF_data/Program/data_cleaning.R")
set.seed(103)
idx.test <- sample(1:nrow(sqf.complete.2023), ceiling(0.1 * nrow(sqf.complete.2023)))
test.set <- sqf.complete.2023[idx.test, ]
train.set <- sqf.complete.2023[-idx.test, ]
str(train.set$SUSPECT_ARRESTED_FLAG)
# fit regular logistic regression
arrest.model <- glm(SUSPECT_ARRESTED_FLAG ~ ., data = train.set, family = "binomial")
summary(arrest.model)
predicted <- predict(arrest.model, test.set, type = "response")
roc.curve <- roc(test.set$SUSPECT_ARRESTED_FLAG, predicted)
auc <- round(auc(test.set$SUSPECT_ARRESTED_FLAG, predicted), 2)
ggroc(roc.curve, col = "blue")
auc
?roc
rocobj <- roc(test.set$SUSPECT_ARRESTED_FLAG, predicted)
auc <- round(auc(test.set$SUSPECT_ARRESTED_FLAG, predicted), 2)
ggroc(rocobj, colour = 'steelblue', size = 2) +
ggtitle(paste0('ROC Curve ', '(AUC = ', auc, ')'))
ggroc(rocobj, colour = 'steelblue', size = 1) +
ggtitle(paste0('ROC Curve ', '(AUC = ', auc, ')'))
ggroc(rocobj, colour = 'steelblue', size = 1) +
ggtitle(paste0('ROC Curve ', '(AUC = ', auc, ')')) +
theme_minimal()
coords(rocobj, "best", ret = c("threshold", "accuracy", "sensitivity", "specificity"))
?roc
ggroc(rocobj, colour = 'steelblue', size = 1) +
ggtitle(paste0('ROC Curve ', '(AUC = ', auc, ')')) +
theme_minimal()
library(mlr3)
# train model with mlr3
task <- as_task_classif(sqf.complete.2023, target = "SUSPECT_ARRESTED_FLAG", positive = "Y")
# train model with mlr3
tsk_classif <- as_task_classif(sqf.complete.2023, target = "SUSPECT_ARRESTED_FLAG", positive = "Y")
tsk_classif$positive
splits <- partition(tsk_classif, ratio = 0.9)
# train model with mlr3
tsk_classif <- as_task_classif(splits$train, target = "SUSPECT_ARRESTED_FLAG", positive = "Y")
splits$train
tsk_classif <- as_task_classif(sqf.complete.2023, target = "SUSPECT_ARRESTED_FLAG", positive = "Y")
lrn_rpart <- lrn("classif.rpart", predict_type = "prob")
splits <- partition(tsk_classif, ratio = 0.9)
lrn_rpart$train(tsk_classif, splits$train)
tsk_classif
prediction
lrn_rpart
splits
splits$train
str(sqf.complete.2023)
lrn()
sqf.2023$WEAPON_FOUND_FLAG <- factor(sqf.2023$WEAPON_FOUND_FLAG)
source("~/Library/Mobile Documents/com~apple~CloudDocs/Documents/01_Studium/13_Jahr_03/21_TrustML/NYPD_SQF_data/Program/data_cleaning.R")
# train model with mlr3
tsk_classif <- as_task_classif(sqf.complete.2023, target = "SUSPECT_ARRESTED_FLAG", positive = "Y")
lrn_rpart <- lrn("classif.rpart", predict_type = "prob")
splits <- partition(tsk_classif, ratio = 0.9)
lrn_rpart$train(tsk_classif, splits$train)
prediction <- lrn_rpart$predict(tsk_classif, splits$test)
prediction
prediction$score
prediction$score(measure)
prediction$confusion
measure <- msr("classif.auc")
prediction$score(measure)
autoplot(prediction)
table(sqf.complete.2023$SUSPECT_ARRESTED_FLAG)
table(sqf.complete.2023$SUMMONS_ISSUED_FLAG)
table(sqf.complete.2023$FRISKED_FLAG)
table(sqf.complete.2023$SEARCHED_FLAG)
autoplot(prediction)
# perform CV
rr <- resample(lrn_rpart, tsk_classif, resampling)
set.seed(103)
tsk_classif <- as_task_classif(sqf.complete.2023, target = "SUSPECT_ARRESTED_FLAG", positive = "Y")
lrn_rpart <- lrn("classif.rpart", predict_type = "prob")
measure <- msr("classif.auc")
splits <- partition(tsk_classif, ratio = 0.9)
# train
lrn_rpart$train(tsk_classif, splits$train)
# predict
prediction <- lrn_rpart$predict(tsk_classif, splits$test)
# evaluate
prediction$confusion
prediction$score(measure)
# with cv
# define CV
resampling <- rsmp("cv", folds = 5)
# perform CV
rr <- resample(lrn_rpart, tsk_classif, resampling)
set.seed(103)
tsk_classif <- as_task_classif(sqf.complete.2023, target = "SUSPECT_ARRESTED_FLAG", positive = "Y")
lrn_rpart <- lrn("classif.rpart", predict_type = "prob")
measure <- msr("classif.auc")
splits <- partition(tsk_classif, ratio = 0.9)
# train
lrn_rpart$train(tsk_classif, splits$train)
# predict
prediction <- lrn_rpart$predict(tsk_classif, splits$test)
# evaluate
prediction$confusion
prediction$score(measure)
autoplot(prediction, type = "roc")
library(mlr3viz)
autoplot(prediction, type = "roc")
rsmp("cv", folds = 5)
# with cv
# define CV
cv5 <- rsmp("cv", folds = 5)
cv5 <- rsmp("cv", folds = 5)
# perform CV
rr <- resample(tsk_classif, lrn_rpart, cv5)
rr
acc <- rr$score(measure)
acc[, .(iteration, classif.auc)]
rr$aggreate(measure)
rr$aggregate(measure)
# get the predictions of each fold
rrp <- rr$prediction()
str(rrp)
rrp[1:2]
# get the predictions of each fold
rrp <- rr$prediction()
rrp[1:2]
# get the predictions of each fold
rrp <- rr$predictions()
rrp[1:2]
rrp[1]
rrp[1]$confusion
rrp[1]
xtabs(~ truth + response, rrp$data())
xtabs(~ truth + response, rrp[1])
xtabs(truth ~ response, rrp[1])
str(rrp[1])
as.data.frame(rrp[1])
rrp[1]
rrp1 <- rrp[1]
rrp1
set.seed(103)
tsk_classif <- as_task_classif(sqf.complete.2023, target = "SUSPECT_ARRESTED_FLAG", positive = "Y")
lrn_rpart <- lrn("classif.rpart", predict_type = "prob")
measure <- msr("classif.auc")
splits <- partition(tsk_classif, ratio = 0.9)
# train
lrn_rpart$train(tsk_classif, splits$train)
# predict
prediction <- lrn_rpart$predict(tsk_classif, splits$test)
# evaluate
prediction$confusion
prediction$score(measure)
prediction
# fit regular logistic regression
# leave 10 % out for testing the fairness definitions
set.seed(103)
idx.test <- sample(1:nrow(sqf.complete.2023), ceiling(0.1 * nrow(sqf.complete.2023)))
test.set <- sqf.complete.2023[idx.test, ]
train.set <- sqf.complete.2023[-idx.test, ]
arrest.model <- glm(SUSPECT_ARRESTED_FLAG ~ ., data = train.set, family = "binomial")
summary(arrest.model)
predicted <- predict(arrest.model, test.set, type = "response")
rocobj <- roc(test.set$SUSPECT_ARRESTED_FLAG, predicted)
auc <- round(auc(test.set$SUSPECT_ARRESTED_FLAG, predicted), 2)
ggroc(rocobj, colour = 'steelblue', size = 1) +
ggtitle(paste0('ROC Curve ', '(AUC = ', auc, ')')) +
theme_minimal()
coords(rocobj, "best", ret = c("threshold", "accuracy", "sensitivity", "specificity"))
prediction
predicted
prediction
test.set
prediction
# leave 10 % out for testing the fairness definitions
set.seed(103)
idx.test <- sample(1:nrow(sqf.complete.2023), ceiling(0.1 * nrow(sqf.complete.2023)))
test.set <- sqf.complete.2023[idx.test, ]
train.set <- sqf.complete.2023[-idx.test, ]
arrest.model <- glm(SUSPECT_ARRESTED_FLAG ~ ., data = train.set, family = "binomial")
summary(arrest.model)
predicted <- predict(arrest.model, test.set, type = "response")
predicted.dt <- data.table(
row_ID = idx.test,
truth = test.set$SUSPECT_ARRESTED_FLAG,
response = predicted
)
predicted.dt
coords(rocobj, "best", ret = c("threshold", "accuracy", "sensitivity", "specificity"))
coords(rocobj, "best")$threshold
as.factor(predicted > coords(rocobj, "best")$threshold)
predicted.dt
rocobj
roc(test.set$SUSPECT_ARRESTED_FLAG, predicted)
# hard label classifier based on optimal threshold or 0.5?
predicted.dt <- data.table(
row_ID = idx.test,
truth = test.set$SUSPECT_ARRESTED_FLAG,
response_opt = as.factor(ifelse(predicted > coords(rocobj, "best")$threshold, "Y", "N")),
prob = predicted
)
predicted.dt
# hard label classifier based on optimal threshold or 0.5?
predicted.dt <- data.table(
row_ID = idx.test,
truth = test.set$SUSPECT_ARRESTED_FLAG,
response_opt = as.factor(ifelse(predicted > coords(rocobj, "best")$threshold, "Y", "N")),
response_05 = as.factor(ifelse(predicted > 0.5, "Y", "N")),
prob = predicted
)
predicted.dt
# hard label classifier based on optimal threshold or 0.5?
predicted.dt <- data.table(
row_ID = idx.test,
truth = test.set$SUSPECT_ARRESTED_FLAG,
response_opt = as.factor(ifelse(predicted < coords(rocobj, "best")$threshold, "Y", "N")),
response_05 = as.factor(ifelse(predicted > 0.5, "Y", "N")),
prob = predicted
)
predicted.dt
# hard label classifier based on optimal threshold or 0.5?
predicted.dt <- data.table(
row_ID = idx.test,
truth = test.set$SUSPECT_ARRESTED_FLAG,
response_opt = as.factor(ifelse(predicted > coords(rocobj, "best")$threshold, "Y", "N")),
response_05 = as.factor(ifelse(predicted > 0.5, "Y", "N")),
prob = predicted
)
predicted.dt
